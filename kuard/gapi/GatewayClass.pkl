/// GatewayClass describes a class of Gateways available to the user for creating Gateway resources.
///
/// It is recommended that this resource be used as a template for Gateways. This means that a Gateway is
/// based on the state of the GatewayClass at the time it was created and changes to the GatewayClass or
/// associated parameters are not propagated down to existing Gateways. This recommendation is intended
/// to limit the blast radius of changes to GatewayClass or associated parameters. If implementations
/// choose to propagate GatewayClass changes to existing Gateways, that MUST be clearly documented by the
/// implementation.
///
/// Whenever one or more Gateways are using a GatewayClass, implementations SHOULD add the
/// `gateway-exists-finalizer.gateway.networking.k8s.io` finalizer on the associated GatewayClass. This
/// ensures that a GatewayClass associated with a Gateway is not deleted while in use.
///
/// GatewayClass is a Cluster level resource.
///
/// This module was generated from the CustomResourceDefinition at
/// <file:///Users/denis.shatokhin/gitlab/personal/rpi/manifests/gateway-api/gatewayclasses.yaml>.
module io.k8s.networking.gateway.v1.GatewayClass

extends "package://pkg.pkl-lang.org/pkl-k8s/k8s@1.1.0#/K8sResource.pkl"

import "package://pkg.pkl-lang.org/pkl-k8s/k8s@1.1.0#/apimachinery/pkg/apis/meta/v1/ObjectMeta.pkl"

fixed apiVersion: "gateway.networking.k8s.io/v1"

fixed kind: "GatewayClass"

/// Standard object's metadata.
///
/// More info: <https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata>.
metadata: ObjectMeta?

/// Spec defines the desired state of GatewayClass.
spec: Spec

/// Status defines the current state of GatewayClass.
///
/// Implementations MUST populate status on all GatewayClass resources which specify their controller
/// name.
///
/// Default if undefined: `{ ["conditions"] { new { ["lastTransitionTime"] = "1970-01-01T00:00:00Z"
/// ["message"] = "Waiting for controller" ["reason"] = "Waiting" ["status"] = "Unknown" ["type"] =
/// "Accepted" } } }`
status: Status?

/// Spec defines the desired state of GatewayClass.
class Spec {
  /// ControllerName is the name of the controller that is managing Gateways of this class. The value of
  /// this field MUST be a domain prefixed path.
  ///
  /// Example: "example.net/gateway-controller".
  ///
  /// This field is not mutable and cannot be empty.
  ///
  /// Support: Core
  controllerName: String(length.isBetween(1, 253), matches(Regex(#"^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*\/[A-Za-z0-9\/\-._~%!$&'()*+,;=:]+$"#)))

  /// Description helps describe a GatewayClass with more details.
  description: String(length <= 64)?

  /// ParametersRef is a reference to a resource that contains the configuration parameters corresponding
  /// to the GatewayClass. This is optional if the controller does not require any additional
  /// configuration.
  ///
  /// ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap, or an
  /// implementation-specific custom resource. The resource can be cluster-scoped or namespace-scoped.
  ///
  /// If the referent cannot be found, the GatewayClass's "InvalidParameters" status condition will be
  /// true.
  ///
  /// A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified, the
  /// merging behavior is implementation specific. It is generally recommended that GatewayClass provides
  /// defaults that can be overridden by a Gateway.
  ///
  /// Support: Implementation-specific
  parametersRef: ParametersRef?
}

/// ParametersRef is a reference to a resource that contains the configuration parameters corresponding
/// to the GatewayClass. This is optional if the controller does not require any additional
/// configuration.
///
/// ParametersRef can reference a standard Kubernetes resource, i.e. ConfigMap, or an
/// implementation-specific custom resource. The resource can be cluster-scoped or namespace-scoped.
///
/// If the referent cannot be found, the GatewayClass's "InvalidParameters" status condition will be
/// true.
///
/// A Gateway for this GatewayClass may provide its own `parametersRef`. When both are specified, the
/// merging behavior is implementation specific. It is generally recommended that GatewayClass provides
/// defaults that can be overridden by a Gateway.
///
/// Support: Implementation-specific
class ParametersRef {
  /// Group is the group of the referent.
  group: String(length <= 253, matches(Regex(#"^$|^[a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*$"#)))

  /// Kind is kind of the referent.
  kind: String(length.isBetween(1, 63), matches(Regex("^[a-zA-Z]([-a-zA-Z0-9]*[a-zA-Z0-9])?$")))

  /// Name is the name of the referent.
  name: String(length.isBetween(1, 253))

  /// Namespace is the namespace of the referent. This field is required when referring to a
  /// Namespace-scoped resource and MUST be unset when referring to a Cluster-scoped resource.
  namespace: String(length.isBetween(1, 63), matches(Regex("^[a-z0-9]([-a-z0-9]*[a-z0-9])?$")))?
}

/// Status defines the current state of GatewayClass.
///
/// Implementations MUST populate status on all GatewayClass resources which specify their controller
/// name.
///
/// Default if undefined: `{ ["conditions"] { new { ["lastTransitionTime"] = "1970-01-01T00:00:00Z"
/// ["message"] = "Waiting for controller" ["reason"] = "Waiting" ["status"] = "Unknown" ["type"] =
/// "Accepted" } } }`
class Status {
  /// Conditions is the current status from the controller for this GatewayClass.
  ///
  /// Controllers should prefer to publish conditions using values of GatewayClassConditionType for the
  /// type of each Condition.
  ///
  /// Default if undefined: `{ new { ["lastTransitionTime"] = "1970-01-01T00:00:00Z" ["message"] =
  /// "Waiting for controller" ["reason"] = "Pending" ["status"] = "Unknown" ["type"] = "Accepted" } }`
  conditions: Listing<Condition>(length <= 8)?
}

/// Condition contains details for one aspect of the current state of this API Resource. --- This struct
/// is intended for direct use as an array at the field path .status.conditions. For example,
///
/// type FooStatus struct{ // Represents the observations of a foo's current state. // Known
/// .status.conditions.type are: "Available", "Progressing", and "Degraded" // +patchMergeKey=type //
/// +patchStrategy=merge // +listType=map // +listMapKey=type Conditions []metav1.Condition
/// `json:"conditions,omitempty" patchStrategy:"merge" patchMergeKey:"type"
/// protobuf:"bytes,1,rep,name=conditions"`
///
/// // other fields }
class Condition {
  /// lastTransitionTime is the last time the condition transitioned from one status to another. This
  /// should be when the underlying condition changed. If that is not known, then using the time when the
  /// API field changed is acceptable.
  lastTransitionTime: String

  /// message is a human readable message indicating details about the transition. This may be an empty
  /// string.
  message: String(length <= 32768)

  /// observedGeneration represents the .metadata.generation that the condition was set based upon. For
  /// instance, if .metadata.generation is currently 12, but the .status.conditions[x].observedGeneration
  /// is 9, the condition is out of date with respect to the current state of the instance.
  observedGeneration: Int(isPositive)?

  /// reason contains a programmatic identifier indicating the reason for the condition's last
  /// transition. Producers of specific condition types may define expected values and meanings for this
  /// field, and whether the values are considered a guaranteed API. The value should be a CamelCase
  /// string. This field may not be empty.
  reason: String(length.isBetween(1, 1024), matches(Regex("^[A-Za-z]([A-Za-z0-9_,:]*[A-Za-z0-9_])?$")))

  /// status of the condition, one of True, False, Unknown.
  status: "True"|"False"|"Unknown"

  /// type of condition in CamelCase or in foo.example.com/CamelCase. --- Many .condition.type values are
  /// consistent across resources like Available, but because arbitrary conditions can be useful (see
  /// .node.status.conditions), the ability to deconflict is important. The regex it matches is
  /// (dns1123SubdomainFmt/)?(qualifiedNameFmt)
  type: String(length <= 316, matches(Regex(#"^([a-z0-9]([-a-z0-9]*[a-z0-9])?(\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A-Za-z0-9_.]*)?[A-Za-z0-9])$"#)))
}
